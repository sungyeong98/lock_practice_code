# 동시성 제어 테스트 및 성능 확인

## 1차 테스트

### `Optimistic Lock`을 통한 동시성 제어
`OptimisticProductService`에 낙관적 락을 사용한 재고 감소 메서드 구현

- 성능표

|       | 1000명 | 10만명 |
|-------|-------|------|
| 소요시간  | 약 5초  | 약 5분 |

### `Pessimistic Lock`을 통한 동시성 제어
`PessimisticProductService`에 비관적 락을 사용한 재고 감소 메서드 구현

- 성능표

|       | 1000명 | 10만명  |
|-------|-------|-------|
| 소요시간  | 약 1초  | 약 28분 |

### `Lettuce Lock`을 통한 동시성 제어
`LettuceProductService`에 lettuce 락을 사용한 재고 감소 메서드 구현

다음 메서드에서는 여러가지 방법으로 테스트를 진행

#### Redis Lock 타임아웃 시간 조정
`RedisLockRepository`의 `lock` 메서드의 시간을 조정해가며 테스트 <br>
`LettuceProductService`의 `decreaseStock`에 있는 thread.sleep 값을 조정해가며 테스트

- 성능표(100ms로 설정하여 테스트 + 타임아웃 3000ms )

|       | 1000명 | 10만명  |
|-------|-------|-------|
| 소요시간  | 약 16초 | 측정 불가 |

- 성능표(10ms로 설정하여 테스트 + 타임아웃 3000ms )

|       | 1000명   | 10만명 |
|-------|---------|--|
| 소요시간  | 약 13.5초 | 측정 불가 |

- 성능표(100ms로 설정하여 테스트 + 타임아웃 10000ms )

|       | 1000명 | 10만명 |
|-------|-------|--|
| 소요시간  | 약 19초 | 측정 불가 |

- 성능표(10ms로 설정하여 테스트 + 타임아웃 10000ms )

|       | 1000명 | 10만명 |
|-------|-------|--|
| 소요시간  | 약 15초 | 측정 불가 |

## 1차 테스트 분석

현재 구현된 분산락들의 결과를 보면 가장 결과가 좋지 않을 것 같던 낙관적 락의 결과가 가장 좋게 나왔다. 
이는 내가 찾아본 내용들과는 전혀 다른 결과였다. <br>
이렇게 나온 원인으로는 첫번째로 낙관적 락에 적용한 재시도 메커니즘이지 않을까 생각한다.
다른 당장의 비관적 락과 비교해도 낙관적 락에는 재시도에 대해서 정교하게 설계가 되어 있는데에 비해,
다른 코드들에서는 그렇지가 않다. 해당 부분에서 성능의 차이가 발생한 것으로 보인다. <br>
두번째 원인으로는 테스트 환경의 문제가 있지 않을까 하는 생각이다. 
